Code,Loops,Recursion,Function_Calls,If_Conditions,Complexity
"def constant_time(arr):
    return arr[0] if arr else None",0,0,0,1,O(1)
"def check_first_element(arr):
    if len(arr) > 0:
        return arr[0]
    return None",0,0,0,1,O(1)
"def is_even(num):
    return num % 2 == 0",0,0,0,0,O(1)
"def get_last_element(arr):
    if not arr:
        return None
    return arr[-1]",0,0,0,1,O(1)
"def swap_values(a, b):
    temp = a
    a = b
    b = temp
    return (a, b)",0,0,0,0,O(1)
"def arithmetic_operation(a, b):
    sum_val = a + b
    diff = a - b
    product = a * b
    quotient = a / b if b != 0 else 'undefined'
    return sum_val, diff, product, quotient",0,0,0,1,O(1)
"def check_parity(number):
    if number % 2 == 0:
        return 'even'
    else:
        return 'odd'",0,0,0,1,O(1)
"def get_middle_element(arr):
    if not arr:
        return None
    mid = len(arr) // 2
    return arr[mid]",0,0,0,1,O(1)
"def absolute_value(num):
    if num < 0:
        return -num
    return num",0,0,0,1,O(1)
"def max_of_two(a, b):
    return a if a > b else b",0,0,0,0,O(1)
"def min_of_three(a, b, c):
    min_val = a
    if b < min_val:
        min_val = b
    if c < min_val:
        min_val = c
    return min_val",0,0,0,2,O(1)
"def calculate_area(length, width):
    return length * width",0,0,0,0,O(1)
"def extract_node_value(node):
    if node is None:
        return None
    return node.value",0,0,0,1,O(1)
"def is_power_of_two(n):
    if n <= 0:
        return False
    return (n & (n - 1)) == 0",0,0,0,1,O(1)
"def set_first_element(arr, value):
    if arr:
        arr[0] = value
    return arr",0,0,0,1,O(1)
"def calculate_distance(x1, y1, x2, y2):
    return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5",0,0,0,0,O(1)
"def has_common_element(set1, set2):
    return len(set1.intersection(set2)) > 0",0,0,0,0,O(1)
"def are_anagrams(str1, str2):
    return sorted(str1) == sorted(str2)",0,0,0,0,O(1)
"def simple_hash(key, table_size):
    return hash(key) % table_size",0,0,0,0,O(1)
"def is_null_or_empty(value):
    return value is None or value == ''",0,0,0,0,O(1)
"def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1",1,0,0,2,O(log n)
"def find_power(base, exponent):
    result = 1
    while exponent > 0:
        if exponent % 2 == 1:
            result *= base
        exponent //= 2
        base *= base
    return result",1,0,0,1,O(log n)
"def count_set_bits(n):
    count = 0
    while n:
        count += n & 1
        n >>= 1
    return count",1,0,0,0,O(log n)
"def gcd_iterative(a, b):
    while b:
        a, b = b, a % b
    return a",1,0,0,0,O(log n)
"def binary_search_recursive(arr, target, left, right):
    if left > right:
        return -1
    mid = (left + right) // 2
    if arr[mid] == target:
        return mid
    elif arr[mid] > target:
        return binary_search_recursive(arr, target, left, mid - 1)
    else:
        return binary_search_recursive(arr, target, mid + 1, right)",0,1,1,2,O(log n)
"def find_closest_power_of_two(n):
    power = 1
    while power * 2 <= n:
        power *= 2
    return power",1,0,0,0,O(log n)
"def exponential_search(arr, target):
    if not arr:
        return -1
    if arr[0] == target:
        return 0
    i = 1
    while i < len(arr) and arr[i] <= target:
        i *= 2
    return binary_search(arr, target, i//2, min(i, len(arr)-1))",1,0,1,2,O(log n)
"def jump_search(arr, target):
    n = len(arr)
    step = int(n ** 0.5)
    prev = 0
    while arr[min(step, n) - 1] < target:
        prev = step
        step += int(n ** 0.5)
        if prev >= n:
            return -1
    while arr[prev] < target:
        prev += 1
        if prev == min(step, n):
            return -1
    if arr[prev] == target:
        return prev
    return -1",2,0,0,3,O(log n)
"def fibonacci_logarithmic(n):
    def matrix_multiply(A, B):
        C = [[0, 0], [0, 0]]
        for i in range(2):
            for j in range(2):
                for k in range(2):
                    C[i][j] += A[i][k] * B[k][j]
        return C
    
    def matrix_power(A, n):
        if n == 1:
            return A
        if n % 2 == 0:
            return matrix_power(matrix_multiply(A, A), n // 2)
        else:
            return matrix_multiply(A, matrix_power(matrix_multiply(A, A), (n - 1) // 2))
    
    if n == 0:
        return 0
    A = [[1, 1], [1, 0]]
    result = matrix_power(A, n)
    return result[0][1]",0,1,3,2,O(log n)
"def find_min_rotated_sorted(arr):
    left, right = 0, len(arr) - 1
    while left < right:
        mid = (left + right) // 2
        if arr[mid] > arr[right]:
            left = mid + 1
        else:
            right = mid
    return arr[left]",1,0,0,1,O(log n)
"def integer_square_root(n):
    x = n
    y = (x + 1) // 2
    while y < x:
        x = y
        y = (x + n // x) // 2
    return x",1,0,0,0,O(log n)
"def double_to_binary_string(number, precision=10):
    integer_part = int(number)
    binary_integer = bin(integer_part)[2:]
    
    fractional_part = number - integer_part
    binary_fractional = ''
    
    while fractional_part > 0 and len(binary_fractional) < precision:
        fractional_part *= 2
        bit = int(fractional_part)
        binary_fractional += str(bit)
        fractional_part -= bit
    
    return binary_integer + '.' + binary_fractional if binary_fractional else binary_integer",2,0,0,1,O(log n)
"def interpolation_search(arr, target):
    low, high = 0, len(arr) - 1
    while low <= high and arr[low] <= target <= arr[high]:
        if low == high:
            return low if arr[low] == target else -1
        pos = low + ((target - arr[low]) * (high - low)) // (arr[high] - arr[low])
        if arr[pos] == target:
            return pos
        if arr[pos] < target:
            low = pos + 1
        else:
            high = pos - 1
    return -1",1,0,0,3,O(log n)
"def cube_root(n):
    x = n
    y = (2 * x + n / (x * x)) / 3
    while abs(y - x) > 0.000001:
        x = y
        y = (2 * x + n / (x * x)) / 3
    return y",1,0,0,0,O(log n)
"def find_peak_element(nums):
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] > nums[mid + 1]:
            right = mid
        else:
            left = mid + 1
    return left",1,0,0,1,O(log n)
"def binary_insert_position(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return left",1,0,0,1,O(log n)
"def linear_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i
    return -1",1,0,0,1,O(n)
"def sum_array(arr):
    total = 0
    for num in arr:
        total += num
    return total",1,0,0,0,O(n)
"def find_max(arr):
    if not arr:
        return None
    max_val = arr[0]
    for num in arr:
        if num > max_val:
            max_val = num
    return max_val",1,0,0,1,O(n)
"def contains_duplicate(arr):
    seen = set()
    for num in arr:
        if num in seen:
            return True
        seen.add(num)
    return False",1,0,0,1,O(n)
"def reverse_array(arr):
    n = len(arr)
    for i in range(n // 2):
        arr[i], arr[n - i - 1] = arr[n - i - 1], arr[i]
    return arr",1,0,0,0,O(n)
"def count_occurrences(arr, target):
    count = 0
    for element in arr:
        if element == target:
            count += 1
    return count",1,0,0,1,O(n)
"def is_palindrome(s):
    s = ''.join(c.lower() for c in s if c.isalnum())
    n = len(s)
    for i in range(n // 2):
        if s[i] != s[n - i - 1]:
            return False
    return True",1,0,0,1,O(n)
"def two_sum(nums, target):
    seen = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in seen:
            return [seen[complement], i]
        seen[num] = i
    return []",1,0,0,1,O(n)
"def first_unique_char(s):
    char_count = {}
    for char in s:
        char_count[char] = char_count.get(char, 0) + 1
    for i, char in enumerate(s):
        if char_count[char] == 1:
            return i
    return -1",2,0,0,1,O(n)
"def find_missing_number(nums):
    n = len(nums)
    expected_sum = n * (n + 1) // 2
    actual_sum = sum(nums)
    return expected_sum - actual_sum",0,0,0,0,O(n)
"def max_profit(prices):
    max_profit = 0
    min_price = float('inf')
    for price in prices:
        if price < min_price:
            min_price = price
        elif price - min_price > max_profit:
            max_profit = price - min_price
    return max_profit",1,0,0,2,O(n)
"def majority_element(nums):
    count = 0
    candidate = None
    for num in nums:
        if count == 0:
            candidate = num
        count += (1 if num == candidate else -1)
    return candidate",1,0,0,2,O(n)
"def calculate_prefix_sum(arr):
    prefix_sum = [0] * len(arr)
    prefix_sum[0] = arr[0]
    for i in range(1, len(arr)):
        prefix_sum[i] = prefix_sum[i-1] + arr[i]
    return prefix_sum",1,0,0,0,O(n)
"def find_single_number(nums):
    result = 0
    for num in nums:
        result ^= num
    return result",1,0,0,0,O(n)
"def valid_parentheses(s):
    stack = []
    mapping = {')': '(', '}': '{', ']': '['}
    for char in s:
        if char in mapping:
            top_element = stack.pop() if stack else '#'
            if mapping[char] != top_element:
                return False
        else:
            stack.append(char)
    return not stack",1,0,0,2,O(n)
"def remove_duplicates(sorted_arr):
    if not sorted_arr:
        return 0
    i = 0
    for j in range(1, len(sorted_arr)):
        if sorted_arr[j] != sorted_arr[i]:
            i += 1
            sorted_arr[i] = sorted_arr[j]
    return i + 1",1,0,0,1,O(n)
"def find_peak_element_linear(nums):
    for i in range(len(nums)):
        if (i == 0 or nums[i-1] < nums[i]) and (i == len(nums)-1 or nums[i] > nums[i+1]):
            return i
    return -1",1,0,0,1,O(n)
"def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr",2,0,0,1,O(n^2)
"def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        min_idx = i
        for j in range(i + 1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr",2,0,0,1,O(n^2)
"def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    return arr",2,0,0,1,O(n^2)
"def two_sum_brute_force(nums, target):
    n = len(nums)
    for i in range(n):
        for j in range(i + 1, n):
            if nums[i] + nums[j] == target:
                return [i, j]
    return []",2,0,0,1,O(n^2)
"def max_subarray_brute_force(nums):
    n = len(nums)
    max_sum = float('-inf')
    for i in range(n):
        current_sum = 0
        for j in range(i, n):
            current_sum += nums[j]
            max_sum = max(max_sum, current_sum)
    return max_sum",2,0,0,0,O(n^2)
"def is_subsequence(s, t):
    m, n = len(s), len(t)
    i, j = 0, 0
    while i < m and j < n:
        if s[i] == t[j]:
            i += 1
        j += 1
    return i == m",1,0,0,1,O(n)
"def longest_palindrome_brute_force(s):
    n = len(s)
    max_length = 0
    max_palindrome = ''
    for i in range(n):
        for j in range(i, n):
            substr = s[i:j+1]
            if substr == substr[::-1] and len(substr) > max_length:
                max_length = len(substr)
                max_palindrome = substr
    return max_palindrome",2,0,0,1,O(n^3)
"def count_pairs_with_sum(arr, target_sum):
    count = 0
    n = len(arr)
    for i in range(n):
        for j in range(i + 1, n):
            if arr[i] + arr[j] == target_sum:
                count += 1
    return count",2,0,0,1,O(n^2)
"def matrix_multiplication(A, B):
    n = len(A)
    C = [[0 for _ in range(n)] for _ in range(n)]
    for i in range(n):
        for j in range(n):
            for k in range(n):
                C[i][j] += A[i][k] * B[k][j]
    return C",3,0,0,0,O(n^3)
"def knapsack_brute_force(weights, values, capacity, n):
    if n == 0 or capacity == 0:
        return 0
    if weights[n-1] > capacity:
        return knapsack_brute_force(weights, values, capacity, n-1)
    else:
        return max(
            values[n-1] + knapsack_brute_force(weights, values, capacity-weights[n-1], n-1),
            knapsack_brute_force(weights, values, capacity, n-1)
        )",0,1,2,2,O(2^n)
"def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)",0,1,2,1,O(2^n)
"def tower_of_hanoi(n, source, auxiliary, target):
    if n == 1:
        print(f'Move disk 1 from {source} to {target}')
        return
    tower_of_hanoi(n-1, source, target, auxiliary)
    print(f'Move disk {n} from {source} to {target}')
    tower_of_hanoi(n-1, auxiliary, source, target)",0,1,2,1,O(2^n)
"def subset_sum(nums, target):
    def backtrack(start, target):
        if target == 0:
            return True
        if target < 0 or start == len(nums):
            return False
        return backtrack(start + 1, target - nums[start]) or backtrack(start + 1, target)
    return backtrack(0, target)",0,1,2,1,O(2^n)
"def power_set(nums):
    result = [[]]
    for num in nums:
        result.extend([curr + [num] for curr in result])
    return result",2,0,0,0,O(2^n)
"def permutations(nums):
    result = []
    def backtrack(start):
        if start == len(nums):
            result.append(nums[:])
            return
        for i in range(start, len(nums)):
            nums[start], nums[i] = nums[i], nums[start]
            backtrack(start + 1)
            nums[start], nums[i] = nums[i], nums[start]
    backtrack(0)
    return result",1,1,1,0,O(n!)
"def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True",1,0,0,4,O(sqrt(n))
"def count_primes_less_than_n(n):
    if n <= 2:
        return 0
    is_prime = [True] * n
    is_prime[0] = is_prime[1] = False
    for i in range(2, int(n**0.5) + 1):
        if is_prime[i]:
            for j in range(i*i, n, i):
                is_prime[j] = False
    return sum(is_prime)",2,0,0,1,O(n log log n)
"def count_sort(arr):
    max_val = max(arr)
    m = max_val + 1
    count = [0] * m
    for a in arr:
        count[a] += 1
    i = 0
    for a in range(m):
        for c in range(count[a]):
            arr[i] = a
            i += 1
    return arr",2,0,0,0,O(n + k)
"def radix_sort(arr):
    RADIX = 10
    maxLength = False
    tmp, placement = -1, 1
    while not maxLength:
        maxLength = True
        buckets = [[] for _ in range(RADIX)]
        for i in arr:
            tmp = i // placement
            buckets[tmp % RADIX].append(i)
            if maxLength and tmp > 0:
                maxLength = False
        a = 0
        for b in range(RADIX):
            for i in buckets[b]:
                arr[a] = i
                a += 1
        placement *= RADIX
    return arr",3,0,0,1,O(n * k)
"def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result.extend(left[i:])
    result.extend(right[j:])
    return result",1,1,2,2,O(n log n)
"def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)",1,1,2,0,O(n log n)
"def heap_sort(arr):
    def heapify(arr, n, i):
        largest = i
        l = 2 * i + 1
        r = 2 * i + 2
        if l < n and arr[l] > arr[largest]:
            largest = l
        if r < n and arr[r] > arr[largest]:
            largest = r
        if largest != i:
            arr[i], arr[largest] = arr[largest], arr[i]
            heapify(arr, n, largest)
    
    n = len(arr)
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)
    return arr",3,1,2,2,O(n log n)
"def quick_select(arr, k):
    if not arr:
        return None
    if len(arr) == 1:
        return arr[0]
    
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    equal = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    
    if k < len(left):
        return quick_select(left, k)
    elif k < len(left) + len(equal):
        return equal[0]
    else:
        return quick_select(right, k - len(left) - len(equal))",1,1,2,1,O(n)
"def topological_sort(graph):
    def dfs(node):
        visited.add(node)
        for neighbor in graph[node]:
            if neighbor not in visited:
                dfs(neighbor)
        result.append(node)
    
    visited = set()
    result = []
    for node in graph:
        if node not in visited:
            dfs(node)
    return result[::-1]",1,1,1,1,O(V + E)
"def bfs(graph, start):
    visited = set([start])
    queue = [start]
    result = []
    
    while queue:
        vertex = queue.pop(0)
        result.append(vertex)
        for neighbor in graph[vertex]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
    return result",1,0,0,1,O(V + E)
"def dijkstra(graph, start):
    distances = {vertex: float('infinity') for vertex in graph}
    distances[start] = 0
    priority_queue = [(0, start)]
    
    while priority_queue:
        current_distance, current_vertex = min(priority_queue)
        priority_queue.remove((current_distance, current_vertex))
        
        if current_distance > distances[current_vertex]:
            continue
            
        for neighbor, weight in graph[current_vertex].items():
            distance = current_distance + weight
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                priority_queue.append((distance, neighbor))
                
    return distances",2,0,0,2,O(V^2)
"def kruskal(graph):
    def find(parent, i):
        if parent[i] != i:
            parent[i] = find(parent, parent[i])
        return parent[i]
        
    def union(parent, rank, x, y):
        root_x = find(parent, x)
        root_y = find(parent, y)
        if root_x != root_y:
            if rank[root_x] < rank[root_y]:
                parent[root_x] = root_y
            elif rank[root_x] > rank[root_y]:
                parent[root_y] = root_x
            else:
                parent[root_y] = root_x
                rank[root_x] += 1
    
    edges = []
    for u in graph:
        for v, w in graph[u].items():
            edges.append((u, v, w))
    
    edges.sort(key=lambda x: x[2])
    
    parent = {vertex: vertex for vertex in graph}
    rank = {vertex: 0 for vertex in graph}
    
    mst = []
    
    for u, v, w in edges:
        if find(parent, u) != find(parent, v):
            mst.append((u, v, w))
            union(parent, rank, u, v)
            
    return mst",1,1,2,2,O(E log E)
"def bellman_ford(graph, start):
    distances = {vertex: float('infinity') for vertex in graph}
    distances[start] = 0
    
    for _ in range(len(graph) - 1):
        for u in graph:
            for v, w in graph[u].items():
                if distances[u] != float('infinity') and distances[u] + w < distances[v]:
                    distances[v] = distances[u] + w
    
    for u in graph:
        for v, w in graph[u].items():
            if distances[u] != float('infinity') and distances[u] + w < distances[v]:
                return None  # Negative cycle detected
                
    return distances",2,0,0,2,O(V * E)
"def floyd_warshall(graph):
    distances = {v: {u: float('infinity') for u in graph} for v in graph}
    
    for v in graph:
        distances[v][v] = 0
        for u, w in graph[v].items():
            distances[v][u] = w
    
    for k in graph:
        for i in graph:
            for j in graph:
                if distances[i][k] + distances[k][j] < distances[i][j]:
                    distances[i][j] = distances[i][k] + distances[k][j]
                    
    return distances",3,0,0,1,O(V^3)
"def longest_common_subsequence(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i-1] == text2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
                
    return dp[m][n]",2,0,0,1,O(m*n)
"def edit_distance(word1, word2):
    m, n = len(word1), len(word2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(m + 1):
        dp[i][0] = i
    for j in range(n + 1):
        dp[0][j] = j
        
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if word1[i-1] == word2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])
                
    return dp[m][n]",2,0,0,1,O(m*n)
"def knapsack_dp(weights, values, capacity):
    n = len(weights)
    dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]
    
    for i in range(1, n + 1):
        for w in range(1, capacity + 1):
            if weights[i-1] <= w:
                dp[i][w] = max(values[i-1] + dp[i-1][w-weights[i-1]], dp[i-1][w])
            else:
                dp[i][w] = dp[i-1][w]
                
    return dp[n][capacity]",2,0,0,1,O(n*W)
"def longest_increasing_subsequence(nums):
    if not nums:
        return 0
        
    n = len(nums)
    dp = [1] * n
    
    for i in range(1, n):
        for j in range(0, i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
                
    return max(dp)",2,0,0,1,O(n^2)
"def coin_change(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    
    for coin in coins:
        for x in range(coin, amount + 1):
            dp[x] = min(dp[x], dp[x - coin] + 1)
            
    return dp[amount] if dp[amount] != float('inf') else -1",2,0,0,0,O(n*amount)
"def matrix_chain_multiplication(p):
    n = len(p) - 1
    m = [[0 for _ in range(n)] for _ in range(n)]
    
    for l in range(2, n + 1):
        for i in range(n - l + 1):
            j = i + l - 1
            m[i][j] = float('inf')
            for k in range(i, j):
                q = m[i][k] + m[k+1][j] + p[i] * p[k+1] * p[j+1]
                if q < m[i][j]:
                    m[i][j] = q
                    
    return m[0][n-1]",3,0,0,2,O(n^3)
"def partition_equal_subset_sum(nums):
    total_sum = sum(nums)
    if total_sum % 2 != 0:
        return False
        
    target = total_sum // 2
    dp = [False] * (target + 1)
    dp[0] = True
    
    for num in nums:
        for j in range(target, num - 1, -1):
            dp[j] |= dp[j - num]
            
    return dp[target]",2,0,0,1,O(n*sum)
"def word_break(s, wordDict):
    n = len(s)
    dp = [False] * (n + 1)
    dp[0] = True
    word_set = set(wordDict)
    
    for i in range(1, n + 1):
        for j in range(i):
            if dp[j] and s[j:i] in word_set:
                dp[i] = True
                break
                
    return dp[n]",2,0,0,2,O(n^2 * k)
"def max_subarray_sum(nums):
    if not nums:
        return 0
        
    current_sum = max_sum = nums[0]
    
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
        
    return max_sum",1,0,0,0,O(n)
"def longest_palindromic_substring(s):
    if not s:
        return ''
        
    n = len(s)
    start, max_len = 0, 1
    dp = [[False] * n for _ in range(n)]
    
    for i in range(n):
        dp[i][i] = True
        
    for i in range(n - 1):
        if s[i] == s[i + 1]:
            dp[i][i + 1] = True
            start = i
            max_len = 2
            
    for length in range(3, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            if s[i] == s[j] and dp[i + 1][j - 1]:
                dp[i][j] = True
                start = i
                max_len = length
                
    return s[start:start + max_len]",3,0,0,1,O(n^2)
"def regular_expression_matching(s, p):
    m, n = len(s), len(p)
    dp = [[False] * (n + 1) for _ in range(m + 1)]
    dp[0][0] = True
    
    for j in range(1, n + 1):
        if p[j-1] == '*':
            dp[0][j] = dp[0][j-2]
            
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if p[j-1] == '*':
                dp[i][j] = dp[i][j-2]
                if p[j-2] == '.' or p[j-2] == s[i-1]:
                    dp[i][j] |= dp[i-1][j]
            elif p[j-1] == '.' or p[j-1] == s[i-1]:
                dp[i][j] = dp[i-1][j-1]
                
    return dp[m][n]",2,0,0,3,O(m*n)
"def is_interleave(s1, s2, s3):
    m, n = len(s1), len(s2)
    if len(s3) != m + n:
        return False
        
    dp = [[False] * (n + 1) for _ in range(m + 1)]
    dp[0][0] = True
    
    for i in range(1, m + 1):
        dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1]
        
    for j in range(1, n + 1):
        dp[0][j] = dp[0][j-1] and s2[j-1] == s3[j-1]
        
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i+j-1]) or (dp[i][j-1] and s2[j-1] == s3[i+j-1])
            
    return dp[m][n]",2,0,0,1,O(m*n)
"def can_partition_k_subsets(nums, k):
    total_sum = sum(nums)
    if total_sum % k != 0:
        return False
        
    target = total_sum // k
    nums.sort(reverse=True)
    if nums[0] > target:
        return False
        
    def backtrack(groups):
        if not nums:
            return True
            
        v = nums.pop(0)
        for i in range(k):
            if groups[i] + v <= target:
                groups[i] += v
                if backtrack(groups):
                    return True
                groups[i] -= v
                if groups[i] == 0:
                    break
                    
        nums.insert(0, v)
        return False
        
    return backtrack([0] * k)",1,1,1,2,O(k^n)
"def count_different_palindromic_subsequences(s):
    n = len(s)
    dp = [[0] * n for _ in range(n)]
    
    for i in range(n):
        dp[i][i] = 1
        
    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            if s[i] != s[j]:
                dp[i][j] = dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1]
            else:
                dp[i][j] = 2 * dp[i+1][j-1]
                left = i + 1
                right = j - 1
                
                while left <= right and s[left] != s[i]:
                    left += 1
                    
                while left <= right and s[right] != s[i]:
                    right -= 1
                    
                if left > right:
                    dp[i][j] += 2
                elif left == right:
                    dp[i][j] += 1
                else:
                    dp[i][j] -= dp[left+1][right-1]
                    
    return dp[0][n-1]",3,0,0,3,O(n^2)
"def wildcard_matching(s, p):
    m, n = len(s), len(p)
    dp = [[False] * (n + 1) for _ in range(m + 1)]
    dp[0][0] = True
    
    for j in range(1, n + 1):
        if p[j-1] == '*':
            dp[0][j] = dp[0][j-1]
            
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if p[j-1] == '*':
                dp[i][j] = dp[i-1][j] or dp[i][j-1]
            elif p[j-1] == '?' or s[i-1] == p[j-1]:
                dp[i][j] = dp[i-1][j-1]
                
    return dp[m][n]",2,0,0,2,O(m*n)
"def max_rectangle_area(heights):
    stack = []
    max_area = 0
    i = 0
    
    while i < len(heights):
        if not stack or heights[stack[-1]] <= heights[i]:
            stack.append(i)
            i += 1
        else:
            top = stack.pop()
            area = heights[top] * (i - stack[-1] - 1 if stack else i)
            max_area = max(max_area, area)
            
    while stack:
        top = stack.pop()
        area = heights[top] * (i - stack[-1] - 1 if stack else i)
        max_area = max(max_area, area)
        
    return max_area",2,0,0,1,O(n)
"def count_prime_numbers(n):
    if n <= 2:
        return 0
        
    is_prime = [True] * n
    is_prime[0] = is_prime[1] = False
    
    for i in range(2, int(n**0.5) + 1):
        if is_prime[i]:
            for j in range(i*i, n, i):
                is_prime[j] = False
                
    return sum(is_prime)",2,0,0,1,O(n log log n)
"def n_queens(n):
    def is_valid(board, row, col):
        for i in range(row):
            if board[i] == col or abs(board[i] - col) == abs(i - row):
                return False
        return True
    
    def backtrack(row, board):
        if row == n:
            result.append(board[:])
            return
        
        for col in range(n):
            if is_valid(board, row, col):
                board[row] = col
                backtrack(row + 1, board)
                
    result = []
    backtrack(0, [-1] * n)
    return result",2,1,2,0,O(n!)
"def traveling_salesman_dp(graph):
    n = len(graph)
    all_visited = (1 << n) - 1
    memo = {}
    
    def tsp(mask, pos):
        if mask == all_visited:
            return graph[pos][0]
            
        if (mask, pos) in memo:
            return memo[(mask, pos)]
            
        ans = float('inf')
        for city in range(n):
            if (mask >> city) & 1 == 0:
                new_ans = graph[pos][city] + tsp(mask | (1 << city), city)
                ans = min(ans, new_ans)
                
        memo[(mask, pos)] = ans
        return ans
        
    return tsp(1, 0)  # Starting from city 0",1,1,1,1,O(n^2 * 2^n)
"def string_to_integer_atoi(s):
    if not s:
        return 0
        
    i = 0
    n = len(s)
    
    # Skip leading whitespace
    while i < n and s[i] == ' ':
        i += 1
        
    if i == n:
        return 0
        
    # Check for sign
    sign = 1
    if s[i] == '+' or s[i] == '-':
        sign = -1 if s[i] == '-' else 1
        i += 1
        
    # Convert digits
    result = 0
    while i < n and s[i].isdigit():
        result = result * 10 + int(s[i])
        i += 1
        
    result *= sign
    
    # Handle overflow
    if result < -2**31:
        return -2**31
    if result > 2**31 - 1:
        return 2**31 - 1
        
    return result",2,0,0,4,O(n)
"def rabin_karp(text, pattern):
    if not pattern or not text:
        return -1
        
    m, n = len(pattern), len(text)
    if m > n:
        return -1
        
    # Prime number for hash calculation
    q = 101
    d = 256  # Number of characters in the input alphabet
    
    # Hash values
    pattern_hash = 0
    text_hash = 0
    
    # The value of h is pow(d, m-1) % q
    h = 1
    for i in range(m-1):
        h = (h * d) % q
        
    # Calculate initial hash values
    for i in range(m):
        pattern_hash = (d * pattern_hash + ord(pattern[i])) % q
        text_hash = (d * text_hash + ord(text[i])) % q
        
    # Slide the pattern over text one by one
    for i in range(n-m+1):
        if pattern_hash == text_hash:
            # Check for characters one by one
            match = True
            for j in range(m):
                if text[i+j] != pattern[j]:
                    match = False
                    break
                    
            if match:
                return i
                
        if i < n-m:
            # Calculate hash for next window
            text_hash = (d * (text_hash - ord(text[i]) * h) + ord(text[i+m])) % q
            if text_hash < 0:
                text_hash += q
                
    return -1",3,0,0,3,O(n*m)
"def z_function(s):
    n = len(s)
    z = [0] * n
    
    left, right = 0, 0
    for i in range(1, n):
        if i <= right:
            z[i] = min(right - i + 1, z[i - left])
            
        while i + z[i] < n and s[z[i]] == s[i + z[i]]:
            z[i] += 1
            
        if i + z[i] - 1 > right:
            left = i
            right = i + z[i] - 1
            
    return z",2,0,0,1,O(n)
"def kmp_search(text, pattern):
    if not pattern:
        return 0
        
    # Compute the LPS array
    def compute_lps(pattern):
        m = len(pattern)
        lps = [0] * m
        
        length = 0
        i = 1
        
        while i < m:
            if pattern[i] == pattern[length]:
                length += 1
                lps[i] = length
                i += 1
            else:
                if length != 0:
                    length = lps[length - 1]
                else:
                    lps[i] = 0
                    i += 1
                    
        return lps
        
    lps = compute_lps(pattern)
    
    n, m = len(text), len(pattern)
    i = j = 0
    
    while i < n:
        if pattern[j] == text[i]:
            i += 1
            j += 1
            
        if j == m:
            return i - j
            
        elif i < n and pattern[j] != text[i]:
            if j != 0:
                j = lps[j - 1]
            else:
                i += 1
                
    return -1",3,0,1,3,O(n+m)
"def manacher_algorithm(s):
    # Transform string to handle even-length palindromes
    t = '#' + '#'.join(s) + '#'
    n = len(t)
    
    # Array to store palindrome lengths
    p = [0] * n
    
    c = r = 0
    for i in range(1, n-1):
        if r > i:
            p[i] = min(r - i, p[2*c - i])
            
        # Attempt to expand palindrome centered at i
        while i + p[i] + 1 < n and i - p[i] - 1 >= 0 and t[i + p[i] + 1] == t[i - p[i] - 1]:
            p[i] += 1
            
        # If palindrome centered at i expands past r,
        # adjust center and right boundary
        if i + p[i] > r:
            c, r = i, i + p[i]
            
    # Find the maximum palindrome length
    max_len, center = max((p[i], i) for i in range(n))
    
    # Transform back to original string indices
    return s[(center - max_len) // 2: (center + max_len) // 2]",2,0,0,2,O(n)
"def minimum_window_substring(s, t):
    if not s or not t:
        return ''
        
    # Dictionary to store character counts for t
    dict_t = {}
    for char in t:
        dict_t[char] = dict_t.get(char, 0) + 1
        
    required = len(dict_t)
    
    # Dictionary to store window character counts
    window_counts = {}
    
    # Variables to track sliding window
    formed = 0
    left, right = 0, 0
    
    # Variables for result
    ans = float('inf'), None, None
    
    while right < len(s):
        # Add one character from the right
        character = s[right]
        window_counts[character] = window_counts.get(character, 0) + 1
        
        # If the frequency of current character equals required count
        if character in dict_t and window_counts[character] == dict_t[character]:
            formed += 1
            
        # Try to minimize the window
        while left <= right and formed == required:
            character = s[left]
            
            # Update result if current window is smaller
            if right - left + 1 < ans[0]:
                ans = (right - left + 1, left, right)
                
            # Remove character from the left
            window_counts[character] -= 1
            if character in dict_t and window_counts[character] < dict_t[character]:
                formed -= 1
                
            # Move left pointer
            left += 1
            
        # Move right pointer
        right += 1
        
    return '' if ans[0] == float('inf') else s[ans[1]: ans[2] + 1]",2,0,0,3,O(n+m)
"def longest_substring_without_repeating_chars(s):
    n = len(s)
    ans = 0
    # Map from character to its index
    mp = {}
    
    i = 0
    for j in range(n):
        if s[j] in mp:
            i = max(mp[s[j]], i)
            
        ans = max(ans, j - i + 1)
        mp[s[j]] = j + 1
        
    return ans",1,0,0,0,O(n)
"def trapping_rain_water(height):
    if not height:
        return 0
        
    n = len(height)
    left_max = [0] * n
    right_max = [0] * n
    
    # Fill left_max
    left_max[0] = height[0]
    for i in range(1, n):
        left_max[i] = max(height[i], left_max[i-1])
        
    # Fill right_max
    right_max[n-1] = height[n-1]
    for i in range(n-2, -1, -1):
        right_max[i] = max(height[i], right_max[i+1])
        
    # Calculate trapped water
    water = 0
    for i in range(n):
        water += min(left_max[i], right_max[i]) - height[i]
        
    return water",3,0,0,0,O(n)
"def reverse_linked_list(head):
    prev = None
    current = head
    
    while current:
        next_temp = current.next
        current.next = prev
        prev = current
        current = next_temp
        
    return prev",1,0,0,0,O(n)
"def detect_cycle_in_linked_list(head):
    if not head or not head.next:
        return False
        
    slow = fast = head
    
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        
        if slow == fast:
            return True
            
    return False",1,0,0,1,O(n)
"def merge_k_sorted_lists(lists):
    import heapq
    
    dummy = ListNode(0)
    current = dummy
    heap = []
    
    # Add the first node from each list to the heap
    for i, lst in enumerate(lists):
        if lst:
            heapq.heappush(heap, (lst.val, i, lst))
            
    while heap:
        val, i, node = heapq.heappop(heap)
        current.next = node
        current = current.next
        
        if node.next:
            heapq.heappush(heap, (node.next.val, i, node.next))
            
    return dummy.next",1,0,1,1,O(n log k)
"def lru_cache(capacity):
    class LRUCache:
        def __init__(self, capacity):
            self.capacity = capacity
            self.cache = {}
            self.next = {}
            self.prev = {}
            self.head = self.tail = None
            
        def _remove(self, key):
            if self.head == key:
                self.head = self.next.get(key)
            if self.tail == key:
                self.tail = self.prev.get(key)
            if key in self.next:
                self.prev[self.next[key]] = self.prev.get(key)
            if key in self.prev:
                self.next[self.prev[key]] = self.next.get(key)
            self.next.pop(key, None)
            self.prev.pop(key, None)
            
        def _add(self, key):
            self.next[key] = None
            if self.tail:
                self.next[self.tail] = key
            self.prev[key] = self.tail
            self.tail = key
            if not self.head:
                self.head = key
                
        def get(self, key):
            if key not in self.cache:
                return -1
            self._remove(key)
            self._add(key)
            return self.cache[key]
            
        def put(self, key, value):
            if key in self.cache:
                self._remove(key)
            self._add(key)
            self.cache[key] = value
            if len(self.cache) > self.capacity:
                lru = self.head
                self._remove(lru)
                self.cache.pop(lru)
                
    return LRUCache(capacity)",2,0,3,2,O(1)
"def binary_tree_max_path_sum(root):
    max_sum = float('-inf')
    
    def max_gain(node):
        nonlocal max_sum
        if not node:
            return 0
            
        left_gain = max(max_gain(node.left), 0)
        right_gain = max(max_gain(node.right), 0)
        
        current_max_path = node.val + left_gain + right_gain
        max_sum = max(max_sum, current_max_path)
        
        return node.val + max(left_gain, right_gain)
        
    max_gain(root)
    return max_sum",0,1,2,0,O(n)
"def serialize_deserialize_binary_tree():
    def serialize(root):
        def dfs(node):
            if not node:
                vals.append('#')
                return
            vals.append(str(node.val))
            dfs(node.left)
            dfs(node.right)
            
        vals = []
        dfs(root)
        return ' '.join(vals)
        
    def deserialize(data):
        def dfs():
            val = next(vals)
            if val == '#':
                return None
            node = TreeNode(int(val))
            node.left = dfs()
            node.right = dfs()
            return node
            
        vals = iter(data.split())
        return dfs()
        
    return serialize, deserialize",2,2,4,2,O(n)
"def skyline_problem(buildings):
    import heapq
    
    # Extract all x coordinates and heights
    points = []
    for left, right, height in buildings:
        points.append((left, -height, right))  # Start point
        points.append((right, 0, 0))           # End point
        
    points.sort()
    
    result = []
    heap = [(0, float('inf'))]  # (height, ending position)
    prev_max = 0
    
    for x, neg_h, r in points:
        # Remove buildings that have ended
        while heap[0][1] <= x:
            heapq.heappop(heap)
            
        # Add new buildings
        if neg_h != 0:
            heapq.heappush(heap, (neg_h, r))
            
        # If max height changed, add to result
        curr_max = -heap[0][0]
        if curr_max != prev_max:
            result.append([x, curr_max])
            prev_max = curr_max
            
    return result",1,0,0,1,O(n log n)
